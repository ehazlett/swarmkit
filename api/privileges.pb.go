// Code generated by protoc-gen-gogo.
// source: privileges.proto
// DO NOT EDIT!

package api

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import github_com_docker_swarmkit_api_deepcopy "github.com/docker/swarmkit/api/deepcopy"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type WindowsRawPrivilegeProfile_Version int32

const (
	// V0 is the initial version of the WindowsRawPrivilegeProfile message.
	WindowsRawPrivilegeProfile_V0 WindowsRawPrivilegeProfile_Version = 0
)

var WindowsRawPrivilegeProfile_Version_name = map[int32]string{
	0: "V0",
}
var WindowsRawPrivilegeProfile_Version_value = map[string]int32{
	"V0": 0,
}

func (x WindowsRawPrivilegeProfile_Version) String() string {
	return proto.EnumName(WindowsRawPrivilegeProfile_Version_name, int32(x))
}
func (WindowsRawPrivilegeProfile_Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{1, 0}
}

type LinuxRawPrivilegeProfile_Version int32

const (
	// V0 is the initial version of the WindowsRawPrivilegeProfile message.
	LinuxRawPrivilegeProfile_V0 LinuxRawPrivilegeProfile_Version = 0
)

var LinuxRawPrivilegeProfile_Version_name = map[int32]string{
	0: "V0",
}
var LinuxRawPrivilegeProfile_Version_value = map[string]int32{
	"V0": 0,
}

func (x LinuxRawPrivilegeProfile_Version) String() string {
	return proto.EnumName(LinuxRawPrivilegeProfile_Version_name, int32(x))
}
func (LinuxRawPrivilegeProfile_Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{2, 0}
}

// POSIX-draft defined capabilities (http://lxr.free-electrons.com/source/include/uapi/linux/capability.h#L96)
type LinuxRawPrivilegeProfile_Capabilities int32

const (
	// In a system with the [_POSIX_CHOWN_RESTRICTED] option d, this
	// overrides the restriction of changing file ownership and group
	// ownership.
	LinuxRawPrivilegeProfile_CAP_CHOWN LinuxRawPrivilegeProfile_Capabilities = 0
	// Override all DAC access, including ACL execute access if
	// [_POSIX_ACL] is d. Excluding DAC access covered by
	// CAP_LINUX_IMMUTABLE.
	LinuxRawPrivilegeProfile_CAP_DAC_OVERRIDE LinuxRawPrivilegeProfile_Capabilities = 1
	// Overrides all DAC restrictions regarding read and search on files
	// and directories, including ACL restrictions if [_POSIX_ACL] is
	// d. Excluding DAC access covered by CAP_LINUX_IMMUTABLE.
	LinuxRawPrivilegeProfile_CAP_DAC_READ_SEARCH LinuxRawPrivilegeProfile_Capabilities = 2
	// Overrides all restrictions about allowed operations on files, where
	// file owner ID must be equal to the user ID, except where CAP_FSETID
	// is applicable. It doesn't override MAC and DAC restrictions.
	LinuxRawPrivilegeProfile_CAP_FOWNER LinuxRawPrivilegeProfile_Capabilities = 3
	// Overrides the following restrictions that the effective user ID
	// shall match the file owner ID when setting the S_ISUID and S_ISGID
	// bits on that file; that the effective group ID (or one of the
	// supplementary group IDs) shall match the file owner ID when setting
	// the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
	// cleared on successful return from chown(2) (not implemented).
	LinuxRawPrivilegeProfile_CAP_FSETID LinuxRawPrivilegeProfile_Capabilities = 4
	// Overrides the restriction that the real or effective user ID of a
	// process sending a signal must match the real or effective user ID
	// of the process receiving the signal.
	LinuxRawPrivilegeProfile_CAP_KILL LinuxRawPrivilegeProfile_Capabilities = 5
	// Allows forged gids on socket credentials passing.
	LinuxRawPrivilegeProfile_CAP_SETGID LinuxRawPrivilegeProfile_Capabilities = 6
	// Allows forged pids on socket credentials passing.
	LinuxRawPrivilegeProfile_CAP_SETUID LinuxRawPrivilegeProfile_Capabilities = 7
	// Without VFS support for capabilities:
	//   Transfer any capability in your permitted set to any pid,
	//   remove any capability in your permitted set from any pid
	// With VFS support for capabilities (neither of above, but)
	//   Add any capability from current's capability bounding set
	//       to the current process' inheritable set
	//   Allow taking bits out of capability bounding set
	//   Allow modification of the securebits for a process
	LinuxRawPrivilegeProfile_CAP_SETPCAP LinuxRawPrivilegeProfile_Capabilities = 8
	// Allow modification of S_IMMUTABLE and S_APPEND file attributes
	LinuxRawPrivilegeProfile_CAP_LINUX_IMMUTABLE LinuxRawPrivilegeProfile_Capabilities = 9
	// Allows binding to ATM VCIs below 32
	LinuxRawPrivilegeProfile_CAP_NET_BIND_SERVICE LinuxRawPrivilegeProfile_Capabilities = 10
	// Allow broadcasting, listen to multicast
	LinuxRawPrivilegeProfile_CAP_NET_BROADCAST LinuxRawPrivilegeProfile_Capabilities = 11
	// Allow activation of ATM control sockets
	LinuxRawPrivilegeProfile_CAP_NET_ADMIN LinuxRawPrivilegeProfile_Capabilities = 12
	// Allow binding to any address for transparent proxying (also via NET_ADMIN)
	LinuxRawPrivilegeProfile_CAP_NET_RAW LinuxRawPrivilegeProfile_Capabilities = 13
	// Allow mlock and mlockall (which doesn't really have anything to do
	// with IPC)
	LinuxRawPrivilegeProfile_CAP_IPC_LOCK LinuxRawPrivilegeProfile_Capabilities = 14
	// Override IPC ownership checks
	LinuxRawPrivilegeProfile_CAP_IPC_OWNER LinuxRawPrivilegeProfile_Capabilities = 15
	// Insert and remove kernel modules - modify kernel without limit
	LinuxRawPrivilegeProfile_CAP_SYS_MODULE LinuxRawPrivilegeProfile_Capabilities = 16
	// Allow sending USB messages to any device via /proc/bus/usb
	LinuxRawPrivilegeProfile_CAP_SYS_RAWIO LinuxRawPrivilegeProfile_Capabilities = 17
	// Allow use of chroot()
	LinuxRawPrivilegeProfile_CAP_SYS_CHROOT LinuxRawPrivilegeProfile_Capabilities = 18
	// Allow ptrace() of any process
	LinuxRawPrivilegeProfile_CAP_SYS_PTRACE LinuxRawPrivilegeProfile_Capabilities = 19
	// Allow configuration of process accounting
	LinuxRawPrivilegeProfile_CAP_SYS_PACCT LinuxRawPrivilegeProfile_Capabilities = 20
	// Allow setting zone reclaim policy
	LinuxRawPrivilegeProfile_CAP_SYS_ADMIN LinuxRawPrivilegeProfile_Capabilities = 21
	// Allow use of reboot()
	LinuxRawPrivilegeProfile_CAP_SYS_BOOT LinuxRawPrivilegeProfile_Capabilities = 22
	// Allow setting cpu affinity on other processes
	LinuxRawPrivilegeProfile_CAP_SYS_NICE LinuxRawPrivilegeProfile_Capabilities = 23
	// Override max number of keymaps
	LinuxRawPrivilegeProfile_CAP_SYS_RESOURCE LinuxRawPrivilegeProfile_Capabilities = 24
	// Allow setting the real-time clock
	LinuxRawPrivilegeProfile_CAP_SYS_TIME LinuxRawPrivilegeProfile_Capabilities = 25
	// Allow vhangup() of tty
	LinuxRawPrivilegeProfile_CAP_SYS_TTY_CONFIG LinuxRawPrivilegeProfile_Capabilities = 26
	// Allow the privileged aspects of mknod()
	LinuxRawPrivilegeProfile_CAP_MKNOD LinuxRawPrivilegeProfile_Capabilities = 27
	// Allow taking of leases on files
	LinuxRawPrivilegeProfile_CAP_LEASE LinuxRawPrivilegeProfile_Capabilities = 28
	// Allow writing the audit log via unicast netlink socket
	LinuxRawPrivilegeProfile_CAP_AUDIT_WRITE LinuxRawPrivilegeProfile_Capabilities = 29
	// Allow configuration of audit via unicast netlink socket
	LinuxRawPrivilegeProfile_CAP_AUDIT_CONTROL LinuxRawPrivilegeProfile_Capabilities = 30
	LinuxRawPrivilegeProfile_CAP_SETFCAP       LinuxRawPrivilegeProfile_Capabilities = 31
	// Override MAC access.
	// The base kernel enforces no MAC policy.
	// An LSM may enforce a MAC policy, and if it does and it chooses
	// to implement capability based overrides of that policy, this is
	// the capability it should use to do so.
	LinuxRawPrivilegeProfile_CAP_MAC_OVERRIDE LinuxRawPrivilegeProfile_Capabilities = 32
	// Allow MAC configuration or state changes.
	// The base kernel requires no MAC configuration.
	// An LSM may enforce a MAC policy, and if it does and it chooses
	// to implement capability based checks on modifications to that
	// policy or the data required to maintain it, this is the
	// capability it should use to do so.
	LinuxRawPrivilegeProfile_CAP_MAC_ADMIN LinuxRawPrivilegeProfile_Capabilities = 33
	// Allow configuring the kernel's syslog (printk behaviour)
	LinuxRawPrivilegeProfile_CAP_SYSLOG LinuxRawPrivilegeProfile_Capabilities = 34
	// Allow triggering something that will wake the system
	LinuxRawPrivilegeProfile_CAP_WAKE_ALARM LinuxRawPrivilegeProfile_Capabilities = 35
	// Allow preventing system suspends
	LinuxRawPrivilegeProfile_CAP_BLOCK_SUSPEND LinuxRawPrivilegeProfile_Capabilities = 36
	// Allow reading the audit log via multicast netlink socket
	LinuxRawPrivilegeProfile_CAP_AUDIT_READ LinuxRawPrivilegeProfile_Capabilities = 37
)

var LinuxRawPrivilegeProfile_Capabilities_name = map[int32]string{
	0:  "CAP_CHOWN",
	1:  "CAP_DAC_OVERRIDE",
	2:  "CAP_DAC_READ_SEARCH",
	3:  "CAP_FOWNER",
	4:  "CAP_FSETID",
	5:  "CAP_KILL",
	6:  "CAP_SETGID",
	7:  "CAP_SETUID",
	8:  "CAP_SETPCAP",
	9:  "CAP_LINUX_IMMUTABLE",
	10: "CAP_NET_BIND_SERVICE",
	11: "CAP_NET_BROADCAST",
	12: "CAP_NET_ADMIN",
	13: "CAP_NET_RAW",
	14: "CAP_IPC_LOCK",
	15: "CAP_IPC_OWNER",
	16: "CAP_SYS_MODULE",
	17: "CAP_SYS_RAWIO",
	18: "CAP_SYS_CHROOT",
	19: "CAP_SYS_PTRACE",
	20: "CAP_SYS_PACCT",
	21: "CAP_SYS_ADMIN",
	22: "CAP_SYS_BOOT",
	23: "CAP_SYS_NICE",
	24: "CAP_SYS_RESOURCE",
	25: "CAP_SYS_TIME",
	26: "CAP_SYS_TTY_CONFIG",
	27: "CAP_MKNOD",
	28: "CAP_LEASE",
	29: "CAP_AUDIT_WRITE",
	30: "CAP_AUDIT_CONTROL",
	31: "CAP_SETFCAP",
	32: "CAP_MAC_OVERRIDE",
	33: "CAP_MAC_ADMIN",
	34: "CAP_SYSLOG",
	35: "CAP_WAKE_ALARM",
	36: "CAP_BLOCK_SUSPEND",
	37: "CAP_AUDIT_READ",
}
var LinuxRawPrivilegeProfile_Capabilities_value = map[string]int32{
	"CAP_CHOWN":            0,
	"CAP_DAC_OVERRIDE":     1,
	"CAP_DAC_READ_SEARCH":  2,
	"CAP_FOWNER":           3,
	"CAP_FSETID":           4,
	"CAP_KILL":             5,
	"CAP_SETGID":           6,
	"CAP_SETUID":           7,
	"CAP_SETPCAP":          8,
	"CAP_LINUX_IMMUTABLE":  9,
	"CAP_NET_BIND_SERVICE": 10,
	"CAP_NET_BROADCAST":    11,
	"CAP_NET_ADMIN":        12,
	"CAP_NET_RAW":          13,
	"CAP_IPC_LOCK":         14,
	"CAP_IPC_OWNER":        15,
	"CAP_SYS_MODULE":       16,
	"CAP_SYS_RAWIO":        17,
	"CAP_SYS_CHROOT":       18,
	"CAP_SYS_PTRACE":       19,
	"CAP_SYS_PACCT":        20,
	"CAP_SYS_ADMIN":        21,
	"CAP_SYS_BOOT":         22,
	"CAP_SYS_NICE":         23,
	"CAP_SYS_RESOURCE":     24,
	"CAP_SYS_TIME":         25,
	"CAP_SYS_TTY_CONFIG":   26,
	"CAP_MKNOD":            27,
	"CAP_LEASE":            28,
	"CAP_AUDIT_WRITE":      29,
	"CAP_AUDIT_CONTROL":    30,
	"CAP_SETFCAP":          31,
	"CAP_MAC_OVERRIDE":     32,
	"CAP_MAC_ADMIN":        33,
	"CAP_SYSLOG":           34,
	"CAP_WAKE_ALARM":       35,
	"CAP_BLOCK_SUSPEND":    36,
	"CAP_AUDIT_READ":       37,
}

func (x LinuxRawPrivilegeProfile_Capabilities) String() string {
	return proto.EnumName(LinuxRawPrivilegeProfile_Capabilities_name, int32(x))
}
func (LinuxRawPrivilegeProfile_Capabilities) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{2, 1}
}

// PrivilegeProfiles specifies per-architecture security configuration/permissions
type PrivilegeProfiles struct {
	// Privileges required to run in Windows
	Windows *WindowsRawPrivilegeProfile `protobuf:"bytes,1,opt,name=windows" json:"windows,omitempty"`
	// Privileges required to run in Linux
	Linux *LinuxRawPrivilegeProfile `protobuf:"bytes,2,opt,name=linux" json:"linux,omitempty"`
}

func (m *PrivilegeProfiles) Reset()                    { *m = PrivilegeProfiles{} }
func (*PrivilegeProfiles) ProtoMessage()               {}
func (*PrivilegeProfiles) Descriptor() ([]byte, []int) { return fileDescriptorPrivileges, []int{0} }

// WindowsRawPrivilegeProfile provides the low level privileges a windows container needs
type WindowsRawPrivilegeProfile struct {
	Version WindowsRawPrivilegeProfile_Version `protobuf:"varint,1,opt,name=version,proto3,enum=docker.swarmkit.v1.WindowsRawPrivilegeProfile_Version" json:"version,omitempty"`
	// JSON string containing credential specs created with gMSA to use with managed service accounts in Windows
	// (see https://blogs.msdn.microsoft.com/containerstuff/2017/01/30/create-a-container-with-active-directory-support/)
	CredentialSpec string `protobuf:"bytes,2,opt,name=credential_spec,json=credentialSpec,proto3" json:"credential_spec,omitempty"`
}

func (m *WindowsRawPrivilegeProfile) Reset()      { *m = WindowsRawPrivilegeProfile{} }
func (*WindowsRawPrivilegeProfile) ProtoMessage() {}
func (*WindowsRawPrivilegeProfile) Descriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{1}
}

// LinuxRawPrivilegeProfile provides the low level privileges a linux container needs
type LinuxRawPrivilegeProfile struct {
	Version LinuxRawPrivilegeProfile_Version `protobuf:"varint,1,opt,name=version,proto3,enum=docker.swarmkit.v1.LinuxRawPrivilegeProfile_Version" json:"version,omitempty"`
	// Linux capabilities required by the container
	Capabilities []LinuxRawPrivilegeProfile_Capabilities `protobuf:"varint,2,rep,packed,name=capabilities,enum=docker.swarmkit.v1.LinuxRawPrivilegeProfile_Capabilities" json:"capabilities,omitempty"`
	// Devices needed by the service
	Devices []*LinuxRawPrivilegeProfile_Device `protobuf:"bytes,3,rep,name=devices" json:"devices,omitempty"`
	// Rather than provide a list of all devices, just mount every device on the node
	AllDevices bool `protobuf:"varint,4,opt,name=all_devices,json=allDevices,proto3" json:"all_devices,omitempty"`
}

func (m *LinuxRawPrivilegeProfile) Reset()      { *m = LinuxRawPrivilegeProfile{} }
func (*LinuxRawPrivilegeProfile) ProtoMessage() {}
func (*LinuxRawPrivilegeProfile) Descriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{2}
}

type LinuxRawPrivilegeProfile_Device struct {
	// The path to the device
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The Read/Write/Mknod access for the device
	Rwm string `protobuf:"bytes,2,opt,name=rwm,proto3" json:"rwm,omitempty"`
}

func (m *LinuxRawPrivilegeProfile_Device) Reset()      { *m = LinuxRawPrivilegeProfile_Device{} }
func (*LinuxRawPrivilegeProfile_Device) ProtoMessage() {}
func (*LinuxRawPrivilegeProfile_Device) Descriptor() ([]byte, []int) {
	return fileDescriptorPrivileges, []int{2, 0}
}

func init() {
	proto.RegisterType((*PrivilegeProfiles)(nil), "docker.swarmkit.v1.PrivilegeProfiles")
	proto.RegisterType((*WindowsRawPrivilegeProfile)(nil), "docker.swarmkit.v1.WindowsRawPrivilegeProfile")
	proto.RegisterType((*LinuxRawPrivilegeProfile)(nil), "docker.swarmkit.v1.LinuxRawPrivilegeProfile")
	proto.RegisterType((*LinuxRawPrivilegeProfile_Device)(nil), "docker.swarmkit.v1.LinuxRawPrivilegeProfile.Device")
	proto.RegisterEnum("docker.swarmkit.v1.WindowsRawPrivilegeProfile_Version", WindowsRawPrivilegeProfile_Version_name, WindowsRawPrivilegeProfile_Version_value)
	proto.RegisterEnum("docker.swarmkit.v1.LinuxRawPrivilegeProfile_Version", LinuxRawPrivilegeProfile_Version_name, LinuxRawPrivilegeProfile_Version_value)
	proto.RegisterEnum("docker.swarmkit.v1.LinuxRawPrivilegeProfile_Capabilities", LinuxRawPrivilegeProfile_Capabilities_name, LinuxRawPrivilegeProfile_Capabilities_value)
}

func (m *PrivilegeProfiles) Copy() *PrivilegeProfiles {
	if m == nil {
		return nil
	}
	o := &PrivilegeProfiles{}
	o.CopyFrom(m)
	return o
}

func (m *PrivilegeProfiles) CopyFrom(src interface{}) {

	o := src.(*PrivilegeProfiles)
	*m = *o
	if o.Windows != nil {
		m.Windows = &WindowsRawPrivilegeProfile{}
		github_com_docker_swarmkit_api_deepcopy.Copy(m.Windows, o.Windows)
	}
	if o.Linux != nil {
		m.Linux = &LinuxRawPrivilegeProfile{}
		github_com_docker_swarmkit_api_deepcopy.Copy(m.Linux, o.Linux)
	}
}

func (m *WindowsRawPrivilegeProfile) Copy() *WindowsRawPrivilegeProfile {
	if m == nil {
		return nil
	}
	o := &WindowsRawPrivilegeProfile{}
	o.CopyFrom(m)
	return o
}

func (m *WindowsRawPrivilegeProfile) CopyFrom(src interface{}) {

	o := src.(*WindowsRawPrivilegeProfile)
	*m = *o
}

func (m *LinuxRawPrivilegeProfile) Copy() *LinuxRawPrivilegeProfile {
	if m == nil {
		return nil
	}
	o := &LinuxRawPrivilegeProfile{}
	o.CopyFrom(m)
	return o
}

func (m *LinuxRawPrivilegeProfile) CopyFrom(src interface{}) {

	o := src.(*LinuxRawPrivilegeProfile)
	*m = *o
	if o.Capabilities != nil {
		m.Capabilities = make([]LinuxRawPrivilegeProfile_Capabilities, len(o.Capabilities))
		copy(m.Capabilities, o.Capabilities)
	}

	if o.Devices != nil {
		m.Devices = make([]*LinuxRawPrivilegeProfile_Device, len(o.Devices))
		for i := range m.Devices {
			m.Devices[i] = &LinuxRawPrivilegeProfile_Device{}
			github_com_docker_swarmkit_api_deepcopy.Copy(m.Devices[i], o.Devices[i])
		}
	}

}

func (m *LinuxRawPrivilegeProfile_Device) Copy() *LinuxRawPrivilegeProfile_Device {
	if m == nil {
		return nil
	}
	o := &LinuxRawPrivilegeProfile_Device{}
	o.CopyFrom(m)
	return o
}

func (m *LinuxRawPrivilegeProfile_Device) CopyFrom(src interface{}) {

	o := src.(*LinuxRawPrivilegeProfile_Device)
	*m = *o
}

func (m *PrivilegeProfiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivilegeProfiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(m.Windows.Size()))
		n1, err := m.Windows.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Linux != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(m.Linux.Size()))
		n2, err := m.Linux.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *WindowsRawPrivilegeProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WindowsRawPrivilegeProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(m.Version))
	}
	if len(m.CredentialSpec) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(len(m.CredentialSpec)))
		i += copy(dAtA[i:], m.CredentialSpec)
	}
	return i, nil
}

func (m *LinuxRawPrivilegeProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxRawPrivilegeProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(m.Version))
	}
	if len(m.Capabilities) > 0 {
		dAtA4 := make([]byte, len(m.Capabilities)*10)
		var j3 int
		for _, num := range m.Capabilities {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Devices) > 0 {
		for _, msg := range m.Devices {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPrivileges(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AllDevices {
		dAtA[i] = 0x20
		i++
		if m.AllDevices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LinuxRawPrivilegeProfile_Device) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinuxRawPrivilegeProfile_Device) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Rwm) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPrivileges(dAtA, i, uint64(len(m.Rwm)))
		i += copy(dAtA[i:], m.Rwm)
	}
	return i, nil
}

func encodeFixed64Privileges(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Privileges(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPrivileges(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}

func (m *PrivilegeProfiles) Size() (n int) {
	var l int
	_ = l
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovPrivileges(uint64(l))
	}
	if m.Linux != nil {
		l = m.Linux.Size()
		n += 1 + l + sovPrivileges(uint64(l))
	}
	return n
}

func (m *WindowsRawPrivilegeProfile) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovPrivileges(uint64(m.Version))
	}
	l = len(m.CredentialSpec)
	if l > 0 {
		n += 1 + l + sovPrivileges(uint64(l))
	}
	return n
}

func (m *LinuxRawPrivilegeProfile) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovPrivileges(uint64(m.Version))
	}
	if len(m.Capabilities) > 0 {
		l = 0
		for _, e := range m.Capabilities {
			l += sovPrivileges(uint64(e))
		}
		n += 1 + sovPrivileges(uint64(l)) + l
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.Size()
			n += 1 + l + sovPrivileges(uint64(l))
		}
	}
	if m.AllDevices {
		n += 2
	}
	return n
}

func (m *LinuxRawPrivilegeProfile_Device) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPrivileges(uint64(l))
	}
	l = len(m.Rwm)
	if l > 0 {
		n += 1 + l + sovPrivileges(uint64(l))
	}
	return n
}

func sovPrivileges(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPrivileges(x uint64) (n int) {
	return sovPrivileges(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PrivilegeProfiles) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrivilegeProfiles{`,
		`Windows:` + strings.Replace(fmt.Sprintf("%v", this.Windows), "WindowsRawPrivilegeProfile", "WindowsRawPrivilegeProfile", 1) + `,`,
		`Linux:` + strings.Replace(fmt.Sprintf("%v", this.Linux), "LinuxRawPrivilegeProfile", "LinuxRawPrivilegeProfile", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WindowsRawPrivilegeProfile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WindowsRawPrivilegeProfile{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`CredentialSpec:` + fmt.Sprintf("%v", this.CredentialSpec) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinuxRawPrivilegeProfile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinuxRawPrivilegeProfile{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Capabilities:` + fmt.Sprintf("%v", this.Capabilities) + `,`,
		`Devices:` + strings.Replace(fmt.Sprintf("%v", this.Devices), "LinuxRawPrivilegeProfile_Device", "LinuxRawPrivilegeProfile_Device", 1) + `,`,
		`AllDevices:` + fmt.Sprintf("%v", this.AllDevices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinuxRawPrivilegeProfile_Device) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinuxRawPrivilegeProfile_Device{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Rwm:` + fmt.Sprintf("%v", this.Rwm) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPrivileges(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PrivilegeProfiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivileges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivilegeProfiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivilegeProfiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &WindowsRawPrivilegeProfile{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linux", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Linux == nil {
				m.Linux = &LinuxRawPrivilegeProfile{}
			}
			if err := m.Linux.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivileges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrivileges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WindowsRawPrivilegeProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivileges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WindowsRawPrivilegeProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WindowsRawPrivilegeProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (WindowsRawPrivilegeProfile_Version(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivileges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrivileges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxRawPrivilegeProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivileges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinuxRawPrivilegeProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinuxRawPrivilegeProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (LinuxRawPrivilegeProfile_Version(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPrivileges
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPrivileges
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v LinuxRawPrivilegeProfile_Capabilities
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPrivileges
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (LinuxRawPrivilegeProfile_Capabilities(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Capabilities = append(m.Capabilities, v)
				}
			} else if wireType == 0 {
				var v LinuxRawPrivilegeProfile_Capabilities
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPrivileges
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (LinuxRawPrivilegeProfile_Capabilities(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capabilities = append(m.Capabilities, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, &LinuxRawPrivilegeProfile_Device{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllDevices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllDevices = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPrivileges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrivileges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinuxRawPrivilegeProfile_Device) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivileges
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Device: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Device: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rwm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivileges
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rwm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivileges(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPrivileges
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrivileges(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrivileges
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrivileges
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPrivileges
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPrivileges
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPrivileges(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPrivileges = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrivileges   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("privileges.proto", fileDescriptorPrivileges) }

var fileDescriptorPrivileges = []byte{
	// 783 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x73, 0xe3, 0x44,
	0x10, 0x8d, 0xe2, 0x24, 0x4e, 0xda, 0x8e, 0xd3, 0x9e, 0x64, 0x77, 0x8d, 0x01, 0xaf, 0x31, 0x50,
	0xe4, 0x40, 0x19, 0xc8, 0x52, 0x54, 0x71, 0x1c, 0x8f, 0x26, 0xc9, 0x54, 0xf4, 0x55, 0x23, 0x39,
	0x26, 0x07, 0x4a, 0xe5, 0x75, 0x44, 0x50, 0xad, 0x36, 0x72, 0x49, 0x26, 0x86, 0x1b, 0x7f, 0x85,
	0x2b, 0xbf, 0x64, 0x8f, 0x1c, 0x39, 0xb2, 0xb9, 0xc1, 0xaf, 0xa0, 0x46, 0xca, 0x04, 0xb1, 0x9b,
	0x3d, 0xf8, 0x36, 0xfd, 0xba, 0xdf, 0x9b, 0xd7, 0xdd, 0x53, 0x03, 0x38, 0xcf, 0xe2, 0x9b, 0x38,
	0x89, 0xae, 0xa2, 0x7c, 0x38, 0xcf, 0xd2, 0x45, 0x4a, 0xc8, 0x65, 0x3a, 0x7b, 0x11, 0x65, 0xc3,
	0x7c, 0x39, 0xcd, 0x5e, 0xbe, 0x88, 0x17, 0xc3, 0x9b, 0xaf, 0xba, 0x07, 0x57, 0xe9, 0x55, 0x5a,
	0xa4, 0xbf, 0x50, 0xa7, 0xb2, 0xb2, 0xdb, 0x58, 0xfc, 0x32, 0xd7, 0xb4, 0xc1, 0x6f, 0x06, 0xb4,
	0x3d, 0xad, 0xe5, 0x65, 0xe9, 0x0f, 0x71, 0x12, 0xe5, 0xe4, 0x14, 0xea, 0xcb, 0xf8, 0xfa, 0x32,
	0x5d, 0xe6, 0x1d, 0xa3, 0x6f, 0x1c, 0x36, 0x8e, 0x86, 0xc3, 0xb7, 0xe5, 0x87, 0x93, 0xb2, 0x44,
	0x4e, 0x97, 0x6f, 0x2a, 0x48, 0x4d, 0x27, 0x23, 0xd8, 0x4c, 0xe2, 0xeb, 0x9f, 0x7e, 0xee, 0xac,
	0x17, 0x3a, 0x9f, 0x3f, 0xa4, 0x63, 0xa9, 0x82, 0x87, 0x54, 0x4a, 0xea, 0xe0, 0x77, 0x03, 0xba,
	0xef, 0xbe, 0x8b, 0x78, 0x50, 0xbf, 0x89, 0xb2, 0x3c, 0x4e, 0xaf, 0x0b, 0xb3, 0xad, 0xa3, 0x6f,
	0x56, 0x33, 0x3b, 0x3c, 0x2f, 0xd9, 0x52, 0xcb, 0x90, 0xcf, 0x60, 0x6f, 0x96, 0x45, 0x97, 0xd1,
	0xf5, 0x22, 0x9e, 0x26, 0x61, 0x3e, 0x8f, 0x66, 0x85, 0xfd, 0x1d, 0xd9, 0xfa, 0x0f, 0xf6, 0xe7,
	0xd1, 0x6c, 0xd0, 0x86, 0xfa, 0x1d, 0x99, 0x6c, 0xc1, 0xfa, 0xf9, 0x97, 0xb8, 0x36, 0xf8, 0x7b,
	0x1b, 0x3a, 0xef, 0x6a, 0x88, 0x38, 0x6f, 0x5a, 0xfd, 0x7a, 0x95, 0x79, 0xbc, 0x6d, 0xf4, 0x7b,
	0x68, 0xce, 0xa6, 0xf3, 0xe9, 0xf3, 0x38, 0x89, 0x17, 0x71, 0x94, 0x77, 0xd6, 0xfb, 0xb5, 0xc3,
	0xd6, 0xd1, 0xb7, 0x2b, 0x89, 0xb2, 0x8a, 0x80, 0xfc, 0x9f, 0x1c, 0xb1, 0xa1, 0x7e, 0x19, 0xdd,
	0xc4, 0xb3, 0x28, 0xef, 0xd4, 0xfa, 0xb5, 0xc3, 0xc6, 0xd1, 0xb3, 0x95, 0x94, 0xcd, 0x82, 0x2b,
	0xb5, 0x06, 0x79, 0x0a, 0x8d, 0x69, 0x92, 0x84, 0x5a, 0x72, 0xa3, 0x6f, 0x1c, 0x6e, 0x4b, 0x98,
	0x26, 0x49, 0x59, 0x98, 0x77, 0x87, 0xb0, 0x55, 0x1e, 0x09, 0x81, 0x8d, 0xf9, 0x74, 0xf1, 0x63,
	0x31, 0xa5, 0x1d, 0x59, 0x9c, 0x09, 0x42, 0x2d, 0x5b, 0xbe, 0xbc, 0xdb, 0x84, 0x3a, 0x3e, 0x34,
	0xfe, 0x7f, 0x36, 0xa1, 0x59, 0xed, 0x88, 0xec, 0xc2, 0x0e, 0xa3, 0x5e, 0xc8, 0x4e, 0xdd, 0x89,
	0x83, 0x6b, 0xe4, 0x00, 0x50, 0x85, 0x26, 0x65, 0xa1, 0x7b, 0xce, 0xa5, 0x14, 0x26, 0x47, 0x83,
	0x3c, 0x81, 0x7d, 0x8d, 0x4a, 0x4e, 0xcd, 0xd0, 0xe7, 0x54, 0xb2, 0x53, 0x5c, 0x27, 0x2d, 0x00,
	0x95, 0x38, 0x76, 0x27, 0x0e, 0x97, 0x58, 0xbb, 0x8f, 0x7d, 0x1e, 0x08, 0x13, 0x37, 0x48, 0x13,
	0xb6, 0x55, 0x7c, 0x26, 0x2c, 0x0b, 0x37, 0x75, 0xd6, 0xe7, 0xc1, 0x89, 0x30, 0x71, 0xab, 0x12,
	0x8f, 0x85, 0x89, 0x75, 0xb2, 0x07, 0x8d, 0xbb, 0xd8, 0x63, 0xd4, 0xc3, 0x6d, 0x7d, 0xaf, 0x25,
	0x9c, 0xf1, 0x77, 0xa1, 0xb0, 0xed, 0x71, 0x40, 0x47, 0x16, 0xc7, 0x1d, 0xd2, 0x81, 0x03, 0x95,
	0x70, 0x78, 0x10, 0x8e, 0x84, 0xa3, 0x0c, 0xc9, 0x73, 0xc1, 0x38, 0x02, 0x79, 0x04, 0xed, 0xfb,
	0x8c, 0x74, 0xa9, 0xc9, 0xa8, 0x1f, 0x60, 0x83, 0xb4, 0x61, 0x57, 0xc3, 0xd4, 0xb4, 0x85, 0x83,
	0x4d, 0x7d, 0x9b, 0x82, 0x24, 0x9d, 0xe0, 0x2e, 0x41, 0x68, 0x2a, 0x40, 0x78, 0x2c, 0xb4, 0x5c,
	0x76, 0x86, 0x2d, 0xcd, 0x52, 0x48, 0xd9, 0xe1, 0x1e, 0x21, 0xd0, 0x2a, 0x3c, 0x5e, 0xf8, 0xa1,
	0xed, 0x9a, 0x63, 0x8b, 0x23, 0xea, 0x32, 0x85, 0x49, 0x3a, 0x11, 0x2e, 0xb6, 0xab, 0x65, 0xec,
	0x54, 0xba, 0x6e, 0x80, 0xa4, 0x8a, 0x79, 0x81, 0xa4, 0x8c, 0xe3, 0x7e, 0x95, 0xea, 0x51, 0xc6,
	0x02, 0x3c, 0xa8, 0x42, 0xa5, 0xd5, 0x47, 0xda, 0x99, 0x82, 0x46, 0x4a, 0xeb, 0x71, 0x15, 0x71,
	0x54, 0xe3, 0x4f, 0xf4, 0xe6, 0x0a, 0x13, 0xdc, 0x77, 0xc7, 0x92, 0x71, 0xec, 0x54, 0xeb, 0x02,
	0x61, 0x73, 0x7c, 0x8f, 0x3c, 0x06, 0x72, 0x8f, 0x04, 0x17, 0x21, 0x73, 0x9d, 0x63, 0x71, 0x82,
	0x5d, 0xfd, 0x10, 0xec, 0x33, 0xc7, 0x35, 0xf1, 0x7d, 0x1d, 0x5a, 0x9c, 0xfa, 0x1c, 0x3f, 0x20,
	0xfb, 0xb0, 0xa7, 0x42, 0x3a, 0x36, 0x45, 0x10, 0x4e, 0xa4, 0x08, 0x38, 0x7e, 0xa8, 0x67, 0x5d,
	0x82, 0xcc, 0x75, 0x02, 0xe9, 0x5a, 0xd8, 0xab, 0xac, 0xf1, 0x58, 0xad, 0xf1, 0xa9, 0xb6, 0x66,
	0x57, 0x1f, 0x55, 0x5f, 0xf7, 0xa9, 0xd0, 0xb2, 0xcf, 0x8f, 0xee, 0x1f, 0xc4, 0x85, 0x6f, 0xb9,
	0x27, 0x38, 0xd0, 0x13, 0x9b, 0xd0, 0x33, 0x1e, 0x52, 0x8b, 0x4a, 0x1b, 0x3f, 0xd6, 0x97, 0x8e,
	0xd4, 0x8a, 0x42, 0x7f, 0xec, 0x7b, 0xdc, 0x31, 0xf1, 0x13, 0x5d, 0x5a, 0x7a, 0x51, 0x8f, 0x14,
	0x3f, 0x1d, 0x75, 0x5e, 0xbd, 0xee, 0xad, 0xfd, 0xf9, 0xba, 0xb7, 0xf6, 0xeb, 0x6d, 0xcf, 0x78,
	0x75, 0xdb, 0x33, 0xfe, 0xb8, 0xed, 0x19, 0x7f, 0xdd, 0xf6, 0x8c, 0xe7, 0x5b, 0xc5, 0xef, 0xfe,
	0xec, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x68, 0x32, 0x6f, 0x3f, 0x28, 0x06, 0x00, 0x00,
}
